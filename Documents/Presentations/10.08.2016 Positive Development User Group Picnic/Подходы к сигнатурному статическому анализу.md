## Подходы к сигнатурному статическому анализу

Привет всем, меня зовут Кочуркин Иван. В данный момент я работаю в Posititve Technologies. В этом докладе я расскажу о коцепции приминения шаблонов в статическом сигнатурном анализаторе исходного кода.

## Этапы работы анализатора Pattern Matching

Прежде всего я опишу как работает анализатор на базе сопоставления с шаблонами или Pattern Matching. Процесс состоит из нескольких этапов:

1. Парсинг исходного кода в зависимое от языка абстрактное синтаксическое дерево AST.
2. Преобразование AST в унифицированный формат.
3. Непосредственно паттерн-матчинг с пользовательскими шаблонами.

Данное разбиение предоставляет возможность описания паттернов или шаблонов под разные языки с помощью одного и того же подхода.

Может показаться странным, как возможно написать анализатор, способный обрабатывать интерпретируемые языки, такие как PHP, не говоря о языках с декларативной природой типа SQL.

На это у нас, конечно же, имеются свои аргументы:

* Во-первых, PM не проводит глубокий анализ. Поэтому для него практически не требуются информация о семантике.
* Во-вторых, языки PL/SQL и T-SQL, являются расширенияем оригинального SQL, в котором добавляются привычные для императивных языков хранимые процедуры. Модуль PM в первую очередь и рассчитан на их анализ. А синтаксис запросов (например, SELECT, DECLARE, GRANT) преобразовывается в вызов обыкновенных функций. Примеры таких шаблонов будут продемонстрированы далее.

## Обоснование разработки анализатора Pattern Matching

Преимуществами pattern matching является простота разработки, поддержки, тестирования. Также он не упадет на плохих файлах с семантическими и даже синтаксическими ошибками, чего не скажешь о динамическом анализе, в котором происходит исполнение кода. Еще одним преимуществом является быстрая возможность подключения нового языка, т.к. модуль сопоставления или матчинга разрабатывать уже не придется.

Недостатками является невозможность анализа семантики кода, учета конфигурации, бизнес-логики приложения и других продвинутых интересных вещей.

## Задачи парсинга

Как уже говорилось, модуль PM состоит из трех основных этапов работы. Первыми двумя являются парсинг текста в AST, второй - преобразование AST в унифицированный формат. На них я останавливаться не буду, потому что времени у нас не так много, да и доклад акцентирует внимание на других вещах. Скажу лишь, что эти этапы не являются примитивными и требуют решения задач, перечисленных на данном слайде. Также добавлю, что для парсинга C# мы использовали Roslyn, а для остальных языков - разрабатывали собственные грамматики под генератор парсеров ANTLR. В общем об этих вещах вы можете подробно почитать в статьях на хабре «Теория и практика парсинга исходников с помощью ANTLR и Roslyn» и «Обработка древовидных структур и унифицированное AST».

## Способы описания шаблонов

Перейдем к третьему этапу, а именно непосредственно к сопоставлению пользовательских шаблонов и унифицированного AST. Шаблон по сути из себя и представляет собой кусочек AST. Все шаблоны необходимо загружать в программу каким-либо образом. На этом слайде отображены способы описания шаблонов.

* Во-первых, шаблоны можно записывать вручную прямо в коде. Для этого не требуется разрабатывать какой-либо парсер. Конечно, данный подход не подходит для записи шаблонов "не программистам", однако может использоваться для написания юнит-тестов. Кроме того, для внесения новых шаблонов, требуется перекомпиляция всей программы.

* Во-вторых, шаблоны можно представлять в каком-нибудь формате обмена данных, например JSON или XML. При данном подходе шаблоны можно загружать извне, однако их синтаксис будет громоздким и неприемлимым для редактирования пользователем. Однако данный формат можно использовать для сериализации древовидных структур (сохранения и загрузки с диска). Стоит отметить, для сериализации также можно использовать и бинарные форматы, такие как Protobuf, MessagePack и другие.

* И, наконец, третий подход заключается в разарботке специального предметно-ориентированного языка (или DSL), который можно было бы легко редактировать, который был бы лаконичным, но который при этом обладал  достаточной выразительной мощностью для описания существующих и будущих шаблонов. Недостатком данного подхода является разработка синтаксиса, парсера, а также невозможность записи всех возможных уязвимостей, потому что он не является тьюринг-полным. Данный подход и был нами выбран. В качестве генератора парсера из грамматики также использовался ANTLR.

## Целесообразность DSL?

Зачем нужен новый еще один стандарт, если существуют, например, регулярные выражения?

## DSL ≠ Regex

DSL - это скорее синтаксические конструкции, похожие на такие из стандартных языков программирования + регулярные выражения. С помощью регулярок тяжело записывать длинные и хоть сколько-нибудь сложные выражения. В них очень неудобно пользоваться обратными ссылками. Ну и у название "DSL" название говорит само за себя: это язык, предназначенный для конкретной предметной области, он внутренний и не будет использоваться в качестве какого-либо общемирового стандарта.

## Синтаксические конструкции в DSL

До разработки собственного DSL были проанализированы уже существующие уязвимости и недостатки, чтобы лучше понять какой синтаксис лучше подойдет. В итоге остановились на конструкциях, представленных на данном слайде. На этом слайде в эти конструкции вставлены такие аббревиатуры, как expr, args и Id.

## Примитивные типы в DSL и Синтаксис DSL

Прежде всего expr, или expression может являться обыкновенным примитивным значением. Однако если нужно матчить не просто один идентификатор или число, а строку, идентификатор по регулярному выражению или диапазон чисел, то необходимо воспользоваться так называемым расширенным выражением, которое обособляется специальными скобками `<[ ]>` (привет разработчикам Nemerle с оператором квазицитирования). Числа, кстати, можно записывать как в десятичном формате, так и в шестнадцатеричном, восьмиричном (с лидирующем 0x и нулем соответственно). Рассматривается возможность поддержки модных бинарных литералов из C# 7.

Также в нашем DSL для многих частоиспользуемых конструкций предусмотрен сокращенный синтаксис, т.е. "синтаксический сахар". Например, решетка обозначает любой Expression, три точки `...` - произвольное количество любых аргументов.

Интересными дополнительными конструкциями являются отрицание условия (например, когда требуется, чтобы в качестве аргумента указывалась не строка) и изюминка нашего DSL, оператор "баян" :). Ну то есть это конечно не баян, а объединение нескольких условий, т.е. логическое ИЛИ, только для для шаблонов. Также была введена конструкция для поиска именно по комментариям, а не по коду: `Comment: “regex”`.

Стоит отметить, что синтаксис нашего DSL все еще в процессе фидбека, разработки и упрощения.

## Примеры шаблонов на DSL

Для того, чтобы лучше понять синтаксис DSL и аргументировать его оправданность, я приведу примеры шаблонов, которые уже используются.
Рассмотрим первый пример:

* Hardcoded Password - справа может стоять любое слово. Слева - переменная, либо обращению к члену класса.
* Второй пример демонстрирует произвольный диапазон чисел (статичный генератор случайных чисел).
* В третьем примере используется уже ограниченный диапазон чисел.
* В четвертом - использование логического или (в данном случае к константе) и произвольное количество аргументов.

## Примеры шаблонов на DSL

Перейдем к следующему слайду.

* Запись из первого примера позволяет создать шаблоны для матчинга комментариев в исходном коде.
* Во втором случае записан пример примитивной SQL инъекции. Слева стоит любая строка, начинающаяся с select не зависимого от регистра (как в SQL). Далее она конкатенируется с любым типом, но только не строкой (например, переменная типа стринг, содержащая в себе точку с запятой и произвольный запрос).
* Cookie Without Secure Attribute демонстриует вызов метода по небезопасной сигнатуре. В этом примере четвертый аргумент отвечает за флаг безопасности.
* В последнем шаблоне, некорректные права для критичных ресурсов, используются восьмеричные числа.

## Примеры шаблонов на DSL

* На следующем слайде первым пунктом идет пустой блок обработки исключения, который актуален сразу для всех языков.
* И, наконец, самый интересный из поддерживающихся на текущий момент в Pattern Matching шаблонов является последний Insecure Cookie. На самом деле, этот шаблон больше подходит для taint-анализа, который мы немного затронем позже, однако получилось реализовать его и с помощью ядра PM. В нем мы видим фиксирующуюся переменную cookie, отрицание выражение и множество Statement. Т.е. добавление куки без установленного флага защищенности.

## Примеры шаблонов под PL/SQL и T-SQL

На следующих слайдах описаны шаблоны и для SQL-подобных языков. Первый шаблон это сравнение с `null` (по спецификации результат такого сравнения - неопределенность) и предоставление чрезмерно расширенных полномочий. Стоит заметить, что, несмотря на то, что GRANT ALL является запросом, в PM это преобразовывается именно в вызов функции.

## Незакрытый курсор в PL/SQL

На последок приведу описания уязвимости, касающейся отсутствия вызова функции закрытия или деаллокации курсора в SQL-подобных языках. Курсоры используются для итерирования коллекций, т.е. по сути для реализации привычных императивных циклов. Если менее привилегированный пользователь сможет захватить "утекший" курсор, это может привести к тому, что записи станут доступны неавторизированным пользователям. Кроме того, это приводит к нестабильности системы и возможности создания DoS злоумышленником.

## Незакрытый курсор в T-SQL

А так шаблон незакрытого курсора выглядит в T-SQL. Здесь так же, как и в случае расширенных полномочий (grant_all), запрос DECLARE CURSOR заменяется на функцию.

## Taint

Pattern Matching предназначен для совсем примитивных шаблонов, в котором практически не учитываются связи между объектами. Логичным его продолжением является более продвинутый анализ, способный учитывать не только синтаксические деревья, но и графы потока управления (CFG, Control Flow Graph), графы потока данных (DFG, Data Flow Graph). В taint-анализаторе также возможно будет совместить семантическую информацию из языко-зависимых анализаторов кода с узлами универсального AST. Например, использовать Roslyn для C# кода. Также важной вещью является то, что все шаблоны PM также будут валидны и в Taint анализаторе. Это касается, например, ранее рассмотренных куки без установленного параметра безопасности и незакрытых курсоров в PL/SQL и T-SQL.

## Шаблон Cross-Site Scripting (XSS) в Taint

На данном слайде продемонстрирован шаблон, описывающий межсайтовое выполнение скриптов под Taint. Taint-уязвимость можно представить в виде трех компонент:

* Первым является Источник данных (TDE, Taint Data Entry). Этот источник потенциально контролируется атакующем. В C# ASP.NET фреймворке такими источниками являются, например, `Params` или `QueryString`.
* Трансформирующая функция (TF, Transform Function). Функция, которая экранирует входной поток данных, например `HtmlEncode`. Данная функция необходима для того, чтобы уменьшить количество false позитивов.
* И Потенциально опасная функция (PVF, Potential Vulnerability Function). Функция, которая выводит код на веб-страницу. Данный код может потенциально может содержать вредоносный скрипт, выполняемый на компьютере пользователя. В ASP.NET такой функцией является, например `Response.Write`.

Как видно на этом слайде, переменная <[@a]> "закрепляется" в источнике данных и используется в транформирующей функции. Результатом трансформирующей функции является другая "закрепленная" переменная <[@b]>, которая, в свою очередь, используется в потенциально уязвимой функции.

С помощью подобного подхода можно будет реализовать также и другие уязвимости, например SQL-инъекции. Понятное дело, что реализовывать подобный анализ с помощью чистого PM - неблагородное занятие.

## Заключение

На этом я заканчиваю свое выступление. На последок я порекомендую прочитать наши статьи с тегом [Application Inspector] на хабре, изучить наши грамматики PHP, T-SQL и PL/SQL с лицензией MIT на гитхабе, возможно даже поконтрибьютить, а также потестировать наш новый бесплатный продукт AppRoof, в который планируется включить ядро Pattern Matching.

Теперь я готов ответить на ваши вопросы.